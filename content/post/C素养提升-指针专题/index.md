---
title: C素养提升-指针专题
description: 在c语言中，内存单元的地址成为指针，专门用来存放地址的变量，称为指针变量。在不影响理解的情况中，有时对地址、指针和指针变量不区分，统称为指针。
slug: C素养提升-指针专题
date: 2021-06-29 00:00:00+0000
image: cover.jpg
categories:
    - C素养提升
tags:
    - C_pointer
    - C语言
    - 指针
---



## 指针

在c语言中，内存单元的地址成为指针，专门用来存放地址的变量，称为指针变量。

在不影响理解的情况中，有时对地址、指针和指针变量不区分，统称为指针。

#### 1、地址和变量

`在计算机内存中，每一个字节单元（Byte），都有一个编号，称为地址`。

编译或函数调用时为其分配内存单元。

变量是对程序中数据存储空间的抽象。

#### 2、指针变量的说明

一般形式如下：

```
<存储类型> <数据类型> * <指针变量名>；

例如,char *pName;
```

指针的存储类型是指针变量本身的存储类型。

指针说明时指定的数据类型不是指针变量本身的数据类型，而是指针目标的数据类型。简称为指针的数据类型。

指针在说明的同时，也可以被赋值初值，成为指针的初始化

一般形式如下：

```
<存储类型> <数据类型> * <指针变量名> = <地址量>；

例如：int a, *pa = &a;
```

在上面的语句中，把变量a的地址作为初值赋了刚说明的int型指针pa。

```
int a = 3;
int *pa = &a;	//相当于:int * pa; pa = &a;
```

下面是一个程序示例：

```c
#include <stdio.h>
int main(int argc, char *argv[])
{
        int a = 10;
        int * p;
        p = &a;
        printf("p:%p a:%p\n",p,&a);
        return 0;
}
```

***可以看到由于整型变量a取地址给指针变量p，最后打印可以发现这两个变量分配的地址都是`0x7fff64003e1c`***

![image-20230112173909015](https://raw.githubusercontent.com/kurisaW/picbed/main/img/202301121739386.png)

下面为了更清楚指针变量赋值与指针变量的地址，我们修改代码：

```c
#include <stdio.h>
int main(int argc, char *argv[])
{
        int a = 10;
        int * p;
        p = &a;
        printf("&p:%p sizeof(p):%d\n",&p,sizeof(p));
        printf("p:%p a:%p\n",p,&a);
        return 0;
}
```

![image-20230112175033147](https://raw.githubusercontent.com/kurisaW/picbed/main/img/202301121750199.png)

***编译查看结果，可以发现上述的`p =  &a`是作为一个赋值操作，将a的地址赋值给了指针变量p，而指针变量本身还会分配一个地址单元，也就是上面显示的`0x7ffc915b44e0`***

一般我们清楚，在指针中`*p`是作为取值，而`&p`则是取地址，我们再次对程序作出修改：

```c
#include <stdio.h>
int main(int argc, char *argv[])
{
        int a = 10;
        int * p;
        p = &a;
        printf("&p:%p sizeof(p):%d\n",&p,sizeof(p));
        printf("p:%p a:%p\n",p,&a);
        printf("%d %p %d \n",*p,*(&p),*(*(&p)));
        return 0;
}
```

![image-20230112182106265](https://raw.githubusercontent.com/kurisaW/picbed/main/img/202301121821672.png)

***那么我们可以看到`a = *p = *(*(&p)) = 10`，仔细理解`*(*(&p))`，也就是对p这个指针变量取地址之后再取值，此时所表示的意思其实一个地址量，也就是`p = *(&p)`,此时对其取地址，可以发现和p所对应的地址相同，此时再对`*(*(&p))`取值，那么也就是对应的一个数据，同理，`&p = &(*(&p))`也就是指针变量p所占用存储区域的地址，作为一个系统随机默认分配的常量，这也是成立的。***

#### 3、指针的目标

指针指向的内存区域中的数据成为指针的目标。

如果它指向的区域是程序中的一个变量的内存空间，则这个变量成为指针的目标变量。简称指针的目标。

在上述程序中，整型指针变量p所指向的就是整型变量a的内存空间，那么也可以称变量a是指针p的目标变量。

#### 4、引入指针

引入指针要注意程序中的px, *px和&px三种表示方法的不同意义。设px为一个指针，则：

>px --- 指针变量，它的内容是地址量

>*px --- 指针所指向的对象，它的内容是数据

>&px --- 指针变量所占用的存储区域的地址，是个常量

#### 5、指针的赋值

指针的赋值运算指的是通过赋值运算符指向指针变量送一个地址值。

向一个指针变量赋值时，送的值必须时地址常量或指针变量，不能时普通的整数（除了赋零）

指针赋值运算常见的有以下几种形式：

```c
// 1、把一个普通变量的地址赋给一个具有相同数据类型的指针：
double x = 15, *px;
px = &x;

// 2、把一个已有地址值的指针变量赋给具有相同数据类型的另一个指针变量：
float a, *px, *py;
px = &a;
py = px;

// 3、把一个数据的地址赋给具有相同数据类型的指针：
int a[20], *pa;
pa = a;	//等价 pa = &a[0]
```

下面是一个程序案例：

```c
#include <stdio.h>
int main(int argc, char *argv[])
{
        int a = 10;
        int * p;
        int * q;

        p = &a;
        q = &a;

        printf("&p:%p %d\n",&p,sizeof(p));
        printf("p:%p a:%p\n",p,&a);
        printf("%d %d\n",a,*p);

        printf("\n\n&q:%p %d\n",&q,sizeof(q));
        printf("%p %d\n",q,*q);

        return 0;
}
```

![image-20230112194158128](https://raw.githubusercontent.com/kurisaW/picbed/main/img/202301121941566.png)

***在上述程序中，我们将a的地址量分别传给指针p和指针q，然后打印这两个指针对应的地址，可以发现两者间相差8位`（一个指针在32位的计算机上，占4个字节；一个指针在64位的计算机上，占8个字节。此处由于我是64位系统，所以一个指针对应的就是8位，）`，也就是说指针p和指针q都是指向目标变量a。***

#### 6、指针运算

指针运算是以`指针变量所存放的地址量作为运算量而进行的运算`。

指针运算的`实质就是地址的计算`。

指针运算的种类是有限的，它只能进行赋值运算、算术运算和关系运算。

| 运算符 | 计算形式 |             意 义              |
| :----: | :------: | :----------------------------: |
|   +    |   px+n   | 指针向地址大的方向移动n个数据  |
|   -    |   px-n   | 指针向地址小的方向移动n个数据  |
|   ++   |   px++   | 指针向地址小的方向移动1个数据  |
|   --   |   px--   | 指针向地址小的方向移动1个数据  |
|   -    |  px-py   | 两个指针之间相隔数据元素的个数 |



* 不同数据类型的两个指针实行加减整数运算是无意义的。

* px+n表示的实际位置的地址量是：(px) + sizeof(px的类型)*n
* px-n表示的实际位置的地址量是：(px) - sizeof(px的类型)*n 
* px-py运算的结果是两指针指向的地址位置之间相隔数据的个数，因此两指针相减不是两指针持有的地址量相减的结果，而是一个整数值，表示两指针之间相隔数据的个数。
* 两指针之间的关系运算表示它们指向的地址位置之间的关系。指向地址大的指针大于指向地址小的指针。
* 指针与一般整型变量之间的关系运算没有意义。但可以和零进行等于或不等于的关系运算，判断指针是否为空。

注意：

`两个指针之间的运算需要有连续的内存地址，否则会发生预想不到的错误`，示例如下：

![image-20230112210030039](https://raw.githubusercontent.com/kurisaW/picbed/main/img/202301122100423.png)

正确的运行示例：

![image-20230112210312170](https://raw.githubusercontent.com/kurisaW/picbed/main/img/202301122103226.png)

`这里也可以与上面的知识点相对应：px-py运算的结果是两指针指向的地址位置之间相隔数据的个数`

下面是一些指针运算的示例：

![image-20230112212116348](https://raw.githubusercontent.com/kurisaW/picbed/main/img/202301122121416.png)

上述程序重要的就是理顺指针的关系以及运算符优先级问题。











---

知识扩展：



**在32位系统与64位系统下，不同数据类型所对应的字节数--->**

|  数据类型   | 32位  | 64位  |                           备注                           |
| :---------: | :---: | :---: | :------------------------------------------------------: |
|    char     |   1   |   1   |                                                          |
|    short    |   2   |   2   |                                                          |
|     int     |   4   |   4   |                                                          |
|    long     |   4   |   8   |                      32位与64位不同                      |
|    float    |   4   |   4   |                                                          |
|   char *    |   4   |   8   |           其他指针类型如long *，int *也是如此            |
|  long long  |   8   |   8   |                                                          |
|   double    |   8   |   8   |                                                          |
| long double | 10/12 | 10/16 | 有效位10字节。32位为了对其实际分配12字节；64位分配16字节 |

